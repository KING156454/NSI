    def mode_securite_absolu(self):
        """Mode s√©curit√© absolu - trouve N'IMPORTE quelle direction valide"""
        tete = self.snake.corps[0]
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        
        # Essayer toutes les directions, m√™me le demi-tour si n√©cessaire
        for direction in directions:
            nouvelle_pos = (tete[0] + direction[0], tete[1] + direction[1])
            
            # V√©rifier seulement les collisions de base
            if (0 <= nouvelle_pos[0] < LARGEUR_GRILLE and
                0 <= nouvelle_pos[1] < HAUTEUR_GRILLE and
                nouvelle_pos not in list(self.snake.corps)[:-1]):
                
                print(f"üÜò Mode s√©curit√© absolu: direction {direction}")
                self.snake.direction = direction
                return
        
        # Si vraiment aucune direction n'est possible, le jeu va se terminer
        print("üíÄ Aucune direction valide trouv√©e - collision imminente")import pygame
import random
from collections import deque

# Initialisation de Pygame
pygame.init()

# Constantes
TAILLE_CELLULE = 30
LARGEUR_GRILLE = 20
HAUTEUR_GRILLE = 15
LARGEUR = LARGEUR_GRILLE * TAILLE_CELLULE
HAUTEUR = HAUTEUR_GRILLE * TAILLE_CELLULE + 100
FPS_INITIAL = 8
FPS_MAX = 20

# Couleurs
NOIR = (0, 0, 0)
BLANC = (255, 255, 255)
VERT = (0, 255, 0)
VERT_FONCE = (0, 180, 0)
ROUGE = (255, 0, 0)
BLEU = (0, 100, 255)
GRIS = (50, 50, 50)
JAUNE = (255, 255, 0)

# Cr√©ation de la fen√™tre
ecran = pygame.display.set_mode((LARGEUR, HAUTEUR))
pygame.display.set_caption("Snake IA Hamiltonienne - Invincible")
horloge = pygame.time.Clock()
police = pygame.font.Font(None, 36)
police_petite = pygame.font.Font(None, 24)

class Snake:
    def __init__(self):
        self.corps = deque([(LARGEUR_GRILLE // 2, HAUTEUR_GRILLE // 2)])
        self.direction = (1, 0)
        
    def deplacer(self):
        tete = self.corps[0]
        nouvelle_tete = (tete[0] + self.direction[0], tete[1] + self.direction[1])
        self.corps.appendleft(nouvelle_tete)
        self.corps.pop()
        
    def grandir(self):
        self.corps.append(self.corps[-1])
        
    def collision_mur(self):
        tete = self.corps[0]
        return tete[0] < 0 or tete[0] >= LARGEUR_GRILLE or tete[1] < 0 or tete[1] >= HAUTEUR_GRILLE
        
    def collision_corps(self):
        tete = self.corps[0]
        return tete in list(self.corps)[1:]

class Jeu:
    def __init__(self):
        self.snake = Snake()
        self.fruits = []
        self.score = 0
        self.fps = FPS_INITIAL
        self.generer_fruits(5)
        self.cycle_hamiltonien = self.generer_cycle_zigzag_vertical()
        self.valider_cycle(self.cycle_hamiltonien)
        self.index_cycle = 0
        self.mode_debug = True
        self.mouvements_totaux = 0
        self.mouvements_sans_fruit = 0
        
    def generer_cycle_zigzag_vertical(self):
        """G√©n√®re un cycle hamiltonien VALIDE en zigzag vertical (sans t√©l√©portation)"""
        cycle = []
        
        for x in range(LARGEUR_GRILLE):
            if x % 2 == 0:
                # Colonne paire : haut ‚Üí bas
                for y in range(HAUTEUR_GRILLE):
                    cycle.append((x, y))
            else:
                # Colonne impaire : bas ‚Üí haut
                for y in range(HAUTEUR_GRILLE - 1, -1, -1):
                    cycle.append((x, y))
        
        return cycle
    
    def valider_cycle(self, cycle):
        """V√©rifie qu'un cycle est valide (pas de t√©l√©portation)"""
        print("\nüîç Validation du cycle hamiltonien...")
        
        # V√©rifier la longueur
        taille_attendue = LARGEUR_GRILLE * HAUTEUR_GRILLE
        if len(cycle) != taille_attendue:
            print(f"‚ùå Cycle incomplet : {len(cycle)} cases au lieu de {taille_attendue}")
            return False
        
        # V√©rifier l'adjacence (pas de t√©l√©portation)
        teleportations = 0
        for i in range(len(cycle)):
            pos_actuelle = cycle[i]
            pos_suivante = cycle[(i + 1) % len(cycle)]
            
            # Distance Manhattan doit √™tre exactement 1
            distance = abs(pos_suivante[0] - pos_actuelle[0]) + abs(pos_suivante[1] - pos_actuelle[1])
            
            if distance != 1:
                if teleportations < 5:
                    print(f"‚ùå T√©l√©portation {pos_actuelle} ‚Üí {pos_suivante} (distance: {distance})")
                teleportations += 1
        
        if teleportations > 0:
            print(f"‚ùå Total de t√©l√©portations d√©tect√©es : {teleportations}")
            return False
        
        print(f"‚úÖ Cycle valide ! {len(cycle)} cases, toutes adjacentes")
        return True
    
    def trouver_index_dans_cycle(self, position):
        """Trouve l'index d'une position dans le cycle hamiltonien"""
        try:
            return self.cycle_hamiltonien.index(position)
        except ValueError:
            # Si pas trouv√©, trouver le plus proche
            min_dist = float('inf')
            meilleur_idx = 0
            for idx, pos in enumerate(self.cycle_hamiltonien):
                dist = abs(pos[0] - position[0]) + abs(pos[1] - position[1])
                if dist < min_dist:
                    min_dist = dist
                    meilleur_idx = idx
            return meilleur_idx
    
    def generer_fruits(self, nombre):
        self.fruits = []
        positions_occupees = set(self.snake.corps)
        
        while len(self.fruits) < nombre:
            fruit = (random.randint(0, LARGEUR_GRILLE - 1), random.randint(0, HAUTEUR_GRILLE - 1))
            if fruit not in positions_occupees and fruit not in self.fruits:
                self.fruits.append(fruit)
    
    def generer_nouveau_fruit(self):
        """G√©n√®re un seul nouveau fruit"""
        positions_occupees = set(self.snake.corps)
        positions_occupees.update(self.fruits)
        
        tentatives = 0
        while tentatives < 1000:
            fruit = (random.randint(0, LARGEUR_GRILLE - 1), random.randint(0, HAUTEUR_GRILLE - 1))
            if fruit not in positions_occupees:
                return fruit
            tentatives += 1
        return None
                
    def verifier_fruit(self):
        tete = self.snake.corps[0]
        if tete in self.fruits:
            self.fruits.remove(tete)
            self.snake.grandir()
            self.score += 1
            self.mouvements_sans_fruit = 0
            
            # Vitesse adaptative
            longueur_serpent = len(self.snake.corps)
            if longueur_serpent < 50:
                self.fps = min(FPS_INITIAL + self.score // 2, FPS_MAX)
            else:
                self.fps = max(8, FPS_MAX - longueur_serpent // 30)
            
            # G√©n√©rer un nouveau fruit
            nouveau_fruit = self.generer_nouveau_fruit()
            if nouveau_fruit:
                self.fruits.append(nouveau_fruit)
        else:
            self.mouvements_sans_fruit += 1
    
    def ia_choisir_direction(self):
        """IA Hamiltonienne avec raccourcis intelligents"""
        self.mouvements_totaux += 1
        
        # D√©tection de deadlock - r√©duire le seuil
        if self.mouvements_sans_fruit > 100:
            print(f"‚ö†Ô∏è  Deadlock d√©tect√© ! ({self.mouvements_sans_fruit} mouvements sans fruit)")
            if self.forcer_raccourci_agressif():
                return
        
        # Essayer un raccourci seulement si on est petit
        ratio = len(self.snake.corps) / (LARGEUR_GRILLE * HAUTEUR_GRILLE)
        if ratio < 0.5:  # Seulement si moins de 50% de remplissage
            if self.peut_prendre_raccourci():
                return
        
        # Suivre le cycle
        self.suivre_cycle_hamiltonien()
    
    def peut_prendre_raccourci(self):
        """V√©rifie si un raccourci est possible - VERSION SIMPLIFI√âE"""
        tete = self.snake.corps[0]
        
        # Ratio de remplissage
        ratio_remplissage = len(self.snake.corps) / (LARGEUR_GRILLE * HAUTEUR_GRILLE)
        
        # Distance adaptative R√âDUITE pour √©viter les blocages
        if ratio_remplissage < 0.2:
            distance_max = 5
        elif ratio_remplissage < 0.4:
            distance_max = 3
        else:
            distance_max = 2
        
        if not self.fruits:
            return False
        
        fruit_cible = min(self.fruits, key=lambda f: abs(f[0] - tete[0]) + abs(f[1] - tete[1]))
        distance = abs(fruit_cible[0] - tete[0]) + abs(fruit_cible[1] - tete[1])
        
        if distance > distance_max:
            return False
        
        chemin = self.bfs(tete, fruit_cible)
        
        if not chemin or len(chemin) < 2:
            return False
        
        prochaine_pos = chemin[1]
        nouvelle_direction = (prochaine_pos[0] - tete[0], prochaine_pos[1] - tete[1])
        
        direction_opposee = (-self.snake.direction[0], -self.snake.direction[1])
        if nouvelle_direction == direction_opposee:
            return False
        
        # Test SIMPLIFI√â - seulement les tests critiques
        if not self.test_raccourci_simplifie(nouvelle_direction, fruit_cible):
            return False
        
        self.snake.direction = nouvelle_direction
        return True
    
    def test_raccourci_simplifie(self, direction, fruit):
        """Test simplifi√© pour √©viter les blocages"""
        tete = self.snake.corps[0]
        nouvelle_tete = (tete[0] + direction[0], tete[1] + direction[1])
        
        # Test 1 : Collision de base
        if (nouvelle_tete[0] < 0 or nouvelle_tete[0] >= LARGEUR_GRILLE or
            nouvelle_tete[1] < 0 or nouvelle_tete[1] >= HAUTEUR_GRILLE or
            nouvelle_tete in list(self.snake.corps)[:-1]):
            return False
        
        # Test 2 : Simuler
        snake_simule = list(self.snake.corps)
        snake_simule.insert(0, nouvelle_tete)
        snake_simule.pop()
        
        if nouvelle_tete == fruit:
            snake_simule.insert(0, nouvelle_tete)
        
        # Test 3 : Espace minimum
        espace = self.calculer_espace_accessible(snake_simule[0], set(snake_simule[1:]))
        
        if espace < len(snake_simule) + 10:
            return False
        
        # Test 4 : Peut atteindre la queue
        chemin_queue = self.bfs_avec_obstacles(snake_simule[0], snake_simule[-1], set(snake_simule[1:-1]))
        if not chemin_queue:
            return False
        
        return True
    
    def forcer_raccourci_agressif(self):
        """Force un raccourci en cas de deadlock"""
        tete = self.snake.corps[0]
        
        if not self.fruits:
            return False
        
        fruit_cible = min(self.fruits, key=lambda f: abs(f[0] - tete[0]) + abs(f[1] - tete[1]))
        chemin = self.bfs(tete, fruit_cible)
        
        if not chemin or len(chemin) < 2:
            return False
        
        prochaine_pos = chemin[1]
        nouvelle_direction = (prochaine_pos[0] - tete[0], prochaine_pos[1] - tete[1])
        
        direction_opposee = (-self.snake.direction[0], -self.snake.direction[1])
        if nouvelle_direction == direction_opposee:
            return False
        
        nouvelle_tete = (tete[0] + nouvelle_direction[0], tete[1] + nouvelle_direction[1])
        
        if (nouvelle_tete[0] < 0 or nouvelle_tete[0] >= LARGEUR_GRILLE or
            nouvelle_tete[1] < 0 or nouvelle_tete[1] >= HAUTEUR_GRILLE or
            nouvelle_tete in list(self.snake.corps)[:-1]):
            return False
        
        espace = self.calculer_espace_accessible(nouvelle_tete, set(self.snake.corps))
        if espace < len(self.snake.corps):
            return False
        
        self.snake.direction = nouvelle_direction
        self.mouvements_sans_fruit = 0
        return True
    
    def test_raccourci_complet(self, direction, fruit):
        """Test multi-niveaux avec scoring"""
        tete = self.snake.corps[0]
        nouvelle_tete = (tete[0] + direction[0], tete[1] + direction[1])
        
        if (nouvelle_tete[0] < 0 or nouvelle_tete[0] >= LARGEUR_GRILLE or
            nouvelle_tete[1] < 0 or nouvelle_tete[1] >= HAUTEUR_GRILLE or
            nouvelle_tete in list(self.snake.corps)[:-1]):
            return False
        
        snake_simule = list(self.snake.corps)
        snake_simule.insert(0, nouvelle_tete)
        snake_simule.pop()
        
        if nouvelle_tete == fruit:
            snake_simule.insert(0, nouvelle_tete)
        
        espace = self.calculer_espace_accessible(snake_simule[0], set(snake_simule[1:]))
        
        # Test de parit√©
        if espace % 2 != len(snake_simule) % 2:
            return False
        
        # Test queue
        chemin_queue = self.bfs_avec_obstacles(snake_simule[0], snake_simule[-1], set(snake_simule[1:-1]))
        if not chemin_queue:
            return False
        
        # Test espace
        if espace < len(snake_simule) * 2:
            return False
        
        # Test fruits accessibles
        for f in self.fruits:
            if f == fruit:
                continue
            chemin_fruit = self.bfs_avec_obstacles(snake_simule[0], f, set(snake_simule[1:]))
            if not chemin_fruit:
                return False
        
        # Simulation
        if not self.simuler_futurs_mouvements(snake_simule, 3):
            return False
        
        return True
    
    def simuler_futurs_mouvements(self, snake_simule, profondeur):
        """Simule plusieurs mouvements en avance"""
        if profondeur == 0:
            return True
        
        tete = snake_simule[0]
        
        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nouvelle_pos = (tete[0] + dx, tete[1] + dy)
            
            if (0 <= nouvelle_pos[0] < LARGEUR_GRILLE and
                0 <= nouvelle_pos[1] < HAUTEUR_GRILLE and
                nouvelle_pos not in snake_simule[1:]):
                
                nouveau_snake = list(snake_simule)
                nouveau_snake.insert(0, nouvelle_pos)
                nouveau_snake.pop()
                
                if self.simuler_futurs_mouvements(nouveau_snake, profondeur - 1):
                    return True
        
        return False
    
    def suivre_cycle_hamiltonien(self):
        """Suit le cycle case par case"""
        tete = self.snake.corps[0]
        index_actuel = self.trouver_index_dans_cycle(tete)
        
        # Essayer de trouver la meilleure direction qui suit le cycle
        meilleures_options = []
        
        for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
            nouvelle_pos = (tete[0] + direction[0], tete[1] + direction[1])
            
            # V√©rifier validit√© basique
            if (nouvelle_pos[0] < 0 or nouvelle_pos[0] >= LARGEUR_GRILLE or
                nouvelle_pos[1] < 0 or nouvelle_pos[1] >= HAUTEUR_GRILLE):
                continue
            
            # Ne pas entrer en collision avec le corps (sauf la queue qui va bouger)
            if nouvelle_pos in list(self.snake.corps)[:-1]:
                continue
            
            # √âviter le demi-tour
            direction_opposee = (-self.snake.direction[0], -self.snake.direction[1])
            if direction == direction_opposee:
                continue
            
            # Trouver l'index dans le cycle
            index_nouvelle = self.trouver_index_dans_cycle(nouvelle_pos)
            
            # Calculer la distance dans le cycle
            if index_nouvelle > index_actuel:
                distance_cycle = index_nouvelle - index_actuel
            else:
                distance_cycle = len(self.cycle_hamiltonien) - index_actuel + index_nouvelle
            
            # Calculer l'espace disponible
            espace = self.calculer_espace_accessible(nouvelle_pos, set(list(self.snake.corps)[:-1]))
            
            # Score combin√© : priorit√© au cycle, mais consid√©rer l'espace
            score = -distance_cycle * 1000 + espace
            
            meilleures_options.append((score, direction, espace))
        
        # Trier par score d√©croissant
        meilleures_options.sort(reverse=True)
        
        # Prendre la meilleure option
        if meilleures_options:
            _, meilleure_direction, _ = meilleures_options[0]
            self.snake.direction = meilleure_direction
        else:
            # Aucune option dans le cycle, mode s√©curit√© absolu
            print("‚ö†Ô∏è Aucune direction dans le cycle disponible, mode s√©curit√©!")
            self.mode_securite_absolu()
    
    def mode_securite(self):
        """Mode s√©curit√©"""
        tete = self.snake.corps[0]
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
        direction_opposee = (-self.snake.direction[0], -self.snake.direction[1])
        
        meilleur_score = -999999
        meilleure_direction = None
        
        for direction in directions:
            if direction == direction_opposee:
                continue
            
            nouvelle_pos = (tete[0] + direction[0], tete[1] + direction[1])
            
            if (0 <= nouvelle_pos[0] < LARGEUR_GRILLE and
                0 <= nouvelle_pos[1] < HAUTEUR_GRILLE and
                nouvelle_pos not in self.snake.corps):
                
                espace = self.calculer_espace_accessible(nouvelle_pos, set(self.snake.corps))
                score = espace * 1000
                
                snake_sim = list(self.snake.corps)
                snake_sim.insert(0, nouvelle_pos)
                snake_sim.pop()
                
                chemin = self.bfs_avec_obstacles(nouvelle_pos, snake_sim[-1], set(snake_sim[:-1]))
                if chemin:
                    score += 10000
                
                if score > meilleur_score:
                    meilleur_score = score
                    meilleure_direction = direction
        
        if meilleure_direction:
            self.snake.direction = meilleure_direction
    
    def bfs(self, debut, fin):
        """BFS standard"""
        queue = deque([(debut, [debut])])
        visite = {debut}
        
        while queue:
            pos, chemin = queue.popleft()
            
            if pos == fin:
                return chemin
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nouvelle_pos = (pos[0] + dx, pos[1] + dy)
                
                if (nouvelle_pos not in visite and
                    0 <= nouvelle_pos[0] < LARGEUR_GRILLE and
                    0 <= nouvelle_pos[1] < HAUTEUR_GRILLE and
                    nouvelle_pos not in self.snake.corps):
                    
                    visite.add(nouvelle_pos)
                    queue.append((nouvelle_pos, chemin + [nouvelle_pos]))
        
        return None
    
    def bfs_avec_obstacles(self, debut, fin, obstacles):
        """BFS avec obstacles"""
        queue = deque([(debut, [debut])])
        visite = {debut}
        
        while queue:
            pos, chemin = queue.popleft()
            
            if pos == fin:
                return chemin
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nouvelle_pos = (pos[0] + dx, pos[1] + dy)
                
                if (nouvelle_pos not in visite and
                    0 <= nouvelle_pos[0] < LARGEUR_GRILLE and
                    0 <= nouvelle_pos[1] < HAUTEUR_GRILLE and
                    nouvelle_pos not in obstacles):
                    
                    visite.add(nouvelle_pos)
                    queue.append((nouvelle_pos, chemin + [nouvelle_pos]))
        
        return None
    
    def calculer_espace_accessible(self, position, obstacles):
        """Calcule l'espace accessible"""
        visite = {position}
        queue = deque([position])
        
        while queue:
            pos = queue.popleft()
            
            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:
                nouvelle_pos = (pos[0] + dx, pos[1] + dy)
                
                if (nouvelle_pos not in visite and
                    0 <= nouvelle_pos[0] < LARGEUR_GRILLE and
                    0 <= nouvelle_pos[1] < HAUTEUR_GRILLE and
                    nouvelle_pos not in obstacles):
                    
                    visite.add(nouvelle_pos)
                    queue.append(nouvelle_pos)
        
        return len(visite)
    
    def dessiner(self):
        ecran.fill(NOIR)
        
        # Dessiner le cycle
        if self.mode_debug:
            for i, pos in enumerate(self.cycle_hamiltonien):
                intensite = 30 + (i % 10) * 2
                couleur = (intensite, intensite, 0)
                rect = pygame.Rect(pos[0] * TAILLE_CELLULE, pos[1] * TAILLE_CELLULE + 100,
                                 TAILLE_CELLULE - 1, TAILLE_CELLULE - 1)
                pygame.draw.rect(ecran, couleur, rect)
        else:
            for x in range(LARGEUR_GRILLE):
                for y in range(HAUTEUR_GRILLE):
                    rect = pygame.Rect(x * TAILLE_CELLULE, y * TAILLE_CELLULE + 100,
                                     TAILLE_CELLULE - 1, TAILLE_CELLULE - 1)
                    pygame.draw.rect(ecran, GRIS, rect)
        
        # Dessiner le serpent
        for i, segment in enumerate(self.snake.corps):
            couleur = VERT if i == 0 else VERT_FONCE
            rect = pygame.Rect(segment[0] * TAILLE_CELLULE, segment[1] * TAILLE_CELLULE + 100,
                             TAILLE_CELLULE - 2, TAILLE_CELLULE - 2)
            pygame.draw.rect(ecran, couleur, rect)
        
        # Dessiner les fruits
        for fruit in self.fruits:
            rect = pygame.Rect(fruit[0] * TAILLE_CELLULE, fruit[1] * TAILLE_CELLULE + 100,
                             TAILLE_CELLULE - 2, TAILLE_CELLULE - 2)
            pygame.draw.rect(ecran, ROUGE, rect)
        
        # Interface
        texte_score = police.render(f"Score: {self.score}", True, BLANC)
        ecran.blit(texte_score, (10, 10))
        
        texte_vitesse = police.render(f"FPS: {self.fps}", True, BLANC)
        ecran.blit(texte_vitesse, (200, 10))
        
        texte_longueur = police.render(f"Longueur: {len(self.snake.corps)}", True, BLANC)
        ecran.blit(texte_longueur, (350, 10))
        
        pourcentage = (len(self.snake.corps) / (LARGEUR_GRILLE * HAUTEUR_GRILLE)) * 100
        texte_prog = police_petite.render(f"Grille: {pourcentage:.1f}%", True, JAUNE)
        ecran.blit(texte_prog, (10, 50))
        
        texte_mouvements = police_petite.render(f"Mouvements: {self.mouvements_totaux}", True, JAUNE)
        ecran.blit(texte_mouvements, (200, 50))
        
        if self.mouvements_sans_fruit > 100:
            avertissement = police_petite.render(f"‚ö†Ô∏è Sans fruit: {self.mouvements_sans_fruit}", True, ROUGE)
            ecran.blit(avertissement, (400, 50))
        
        mode_texte = "Zigzag Vertical" if not self.mode_debug else "Debug: Cycle visible"
        texte_mode = police_petite.render(mode_texte, True, BLEU)
        ecran.blit(texte_mode, (10, 75))
        
        pygame.display.flip()

def main():
    jeu = Jeu()
    en_cours = True
    
    print("üêç Snake IA Hamiltonienne - Mode Invincible")
    print("=" * 60)
    print("Strat√©gies impl√©ment√©es:")
    print("‚úì Cycle Hamiltonien en Zigzag Vertical (VALIDE)")
    print("‚úì Validation compl√®te du cycle")
    print("‚úì Raccourcis adaptatifs (2-8 cases)")
    print("‚úì D√©tection de pi√®ges de parit√©")
    print("‚úì Simulation 3 coups en avance")
    print("‚úì Vitesse adaptative")
    print("‚úì Syst√®me de scoring pond√©r√©")
    print("‚úì D√©tection de deadlock (>150 mouvements)")
    print("=" * 60)
    print("\nüí° Appuyez sur 'D' pour toggle le mode debug")
    print("=" * 60)
    
    while en_cours:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                en_cours = False
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_d:
                    jeu.mode_debug = not jeu.mode_debug
        
        jeu.ia_choisir_direction()
        jeu.snake.deplacer()
        
        if jeu.snake.collision_mur() or jeu.snake.collision_corps():
            print(f"\n‚ùå Game Over!")
            print(f"Score final: {jeu.score}")
            print(f"Longueur finale: {len(jeu.snake.corps)}")
            print(f"Pourcentage: {(len(jeu.snake.corps) / (LARGEUR_GRILLE * HAUTEUR_GRILLE)) * 100:.1f}%")
            print(f"Mouvements totaux: {jeu.mouvements_totaux}")
            en_cours = False
        
        jeu.verifier_fruit()
        
        if jeu.score > 0 and jeu.score % 50 == 0 and jeu.mouvements_totaux % 100 == 0:
            print(f"üìä Score: {jeu.score} | Longueur: {len(jeu.snake.corps)}")
        
        jeu.dessiner()
        horloge.tick(jeu.fps)
    
    pygame.quit()

if __name__ == "__main__":
    main()
